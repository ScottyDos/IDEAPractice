package com.hisen.programLogicOfThinking;

/**
 * 全面理解继承，透彻理解类和继承的实现原理
 * Created by hisen on 17-8-15.
 * E-mail: hisenyuan@gmail.com
 */
public class Part6 {

  /**
   * toString()方法的目的是返回一个对象的文本描述
   * 下面是toString的源码
   * hashCode()返回一个对象的哈希值
   *
   * 为什么要这么写呢？写类名是可以理解的，表示对象的类型，
   * 而写哈希值则是不得已的，因为Object类并不知道具体对象的属性，
   * 不知道怎么用文本描述，但又需要区分不同对象，只能是写一个哈希值。
   */
  public String toString() {
    // toHexString 返回16进制的表示
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
  }

  /**
   * 一个类最多只能有一个父类,可以实现多个接口
   * super的使用与this有点像，但super和this是不同的，
   * this引用一个对象，是实实在在存在的，可以作为函数参数，可以作为返回值，
   * 但super只是一个关键字，不能作为参数和返回值，它只是用于告诉编译器访问父类的相关变量和方法。
   *
   * 如果父类只有带参数的构造方法，那么子类必须通过super调用，否则会报错
   */
  public static class Base {

    public Base() {
      test();
    }

    public void test() {
    }
  }

  public static class Child extends Base {

    private int a = 123;

    public Child() {
    }

    public void test() {
      System.out.println(a);
    }
  }

  /**
   * 类的加载
   * 在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，
   * 加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。
   *
   * 一个类的信息主要包括以下部分：
   * 类变量（静态变量）
   * 类初始化代码
   * 类方法（静态方法）
   * 实例变量
   * 实例初始化代码
   * 实例方法
   * 父类信息引用
   *
   * 类初始化代码包括：
   * 定义静态变量时的赋值语句
   * 静态初始化代码块
   *
   * 实例初始化代码包括：
   * 定义实例变量时的赋值语句
   * 实例初始化代码块
   * 构造方法
   *
   * 类加载过程包括：
   * 分配内存保存类的信息
   * 给类变量赋默认值
   * 加载父类
   * 设置父子关系
   * 执行类初始化代码
   *
   * 内存分为栈和堆，
   * 栈存放函数的局部变量，
   * 而堆存放动态分配的对象，
   * 还有一个内存区，存放类的信息，这个区在Java中称之为方法区。
   *
   * 正确使用继承
   * 如果要使用继承，怎么正确使用呢？使用继承大概主要有三种场景：
   * 基类是别人写的，我们写子类。
   * 我们写基类，别人可能写子类。
   * 基类、子类都是我们写的。
   *
   * 第一种场景中，基类主要是Java API，其他框架或类库中的类，在这种情况下，我们主要通过扩展基类，实现自定义行为，这种情况下需要注意的是：
   * 重写方法不要改变预期的行为。
   * 阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的调用关系。
   * 在基类修改的情况下，阅读其修改说明，相应修改子类。
   *
   * 第二种场景中，我们写基类给别人用，在这种情况下，需要注意的是：
   * 使用继承反映真正的"is-a"关系，只将真正公共的部分放到基类。
   * 对不希望被重写的公开方法添加final修饰符。
   * 写文档，说明可重写方法的实现机制，为子类提供指导，告诉子类应该如何重写。
   * 在基类修改可能影响子类时，写修改说明。
   *
   * 第三种场景，我们既写基类、也写子类，关于基类，注意事项和第二种场景类似，关于子类，注意事项和第一种场景类似，不过程序都由我们控制，要求可以适当放松一些。
   */


  public static void main(String[] args) {
    Part6 part6 = new Part6();
    System.out.println(part6.toString());
    //com.hisen.xxx.Part6@1218025c

    // 关于继承
    Child c = new Child();
    c.test();
//    0
//    123
    /**
     * 出现这的原因：
     * 在new Child()的过程中会调用Base的test()
     * 但是test被子类重写，所以会调用Chile的test()
     * 又因为a那时候还没有赋值，在初始化，所以打印0
     * 第二次是正常执行，打印123
     */
  }
}
